/**
 * Step 6: OpenAPI specs → annotation files
 *
 * Two functions:
 *   generateFederalAnnotations(baseSpecPath, outPath)
 *     Extracts federal-level x-extensions from the base schema into a single
 *     federal.yaml file.
 *
 *   generateStateAnnotations(resolvedSpecPath, outPath, stateName)
 *     Extracts state-level x-extensions from a resolved spec into a single
 *     {state}.yaml file.
 *
 * Output: generated/annotations/{federal,california,colorado}.yaml
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { dirname, relative, join } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, '..', '..');
import yaml from 'js-yaml';
import {
  INCLUDED_ENTITIES,
  ANNOTATION_PATH_PREFIX,
  FEDERAL_PROGRAM_MAP,
  CA_PROGRAM_MAP,
  CO_PROGRAM_MAP,
} from './entity-map.js';

// Build reverse maps: x-extension key → display name
const FEDERAL_KEYS = new Map();
for (const [col, key] of Object.entries(FEDERAL_PROGRAM_MAP)) {
  FEDERAL_KEYS.set(key, col);
}

const STATE_PROGRAM_MAPS = {
  california: CA_PROGRAM_MAP,
  colorado: CO_PROGRAM_MAP,
};

// State x-extension key patterns: x-ca-*, x-co-*
const STATE_META_PATTERNS = {
  california: { statute: 'x-ca-statute', notes: 'x-ca-notes' },
  colorado: { statute: 'x-co-statute', notes: 'x-co-notes' },
};

// ---------------------------------------------------------------------------
// Shared helpers
// ---------------------------------------------------------------------------

function walkProperties(schemas, visitor) {
  for (const entity of INCLUDED_ENTITIES) {
    const schema = schemas[entity];
    if (!schema?.properties) continue;

    const prefix = ANNOTATION_PATH_PREFIX[entity];

    for (const [propName, prop] of Object.entries(schema.properties)) {
      if (prop.$ref) continue;
      if (prop.type === 'array' && prop.items?.$ref) continue;

      // Nested objects (Household sub-groups)
      if (prop.type === 'object' && prop.properties) {
        for (const [subName, subProp] of Object.entries(prop.properties)) {
          const dotPath = prefix ? `${prefix}.${propName}.${subName}` : `${propName}.${subName}`;
          visitor(subProp, dotPath);
        }
        continue;
      }

      const dotPath = prefix ? `${prefix}.${propName}` : propName;
      visitor(prop, dotPath);
    }
  }
}

function writeAnnotationFile(filePath, schemaRef, fields, description, sourcePath) {
  mkdirSync(dirname(filePath), { recursive: true });

  const header = [
    `# ${description}`,
    `# Source: ${sourcePath}`,
    '# Generated by the CSV-to-overlay pipeline. Do not edit by hand.',
    '',
  ].join('\n');

  const body = yaml.dump(
    { schema: schemaRef, fields },
    { lineWidth: 120, noRefs: true, quotingType: '"', forceQuotes: false },
  );

  writeFileSync(filePath, header + body);
}

// ---------------------------------------------------------------------------
// Federal annotations (from base schema, run once)
// ---------------------------------------------------------------------------

/**
 * @param {string} baseSpecPath - Path to the federal base OpenAPI YAML
 * @param {string} outPath - Output file path (e.g. generated/annotations/federal.yaml)
 * @param {string} [schemaRef='applications/Application']
 */
export function generateFederalAnnotations(baseSpecPath, outPath, schemaRef = 'applications/Application') {
  const spec = yaml.load(readFileSync(baseSpecPath, 'utf-8'));
  const schemas = spec.components?.schemas || {};

  const fields = {};
  let count = 0;

  walkProperties(schemas, (prop, dotPath) => {
    if (!prop || typeof prop !== 'object') return;

    const fed = {};
    let hasContent = false;

    if (prop.description) fed.label = prop.description;
    if (prop['x-source']) { fed.source = prop['x-source']; hasContent = true; }
    if (prop['x-statute']) { fed.statute = prop['x-statute']; hasContent = true; }
    if (prop['x-obbba']) { fed.obbba = prop['x-obbba']; hasContent = true; }

    const programs = {};
    for (const [key, displayName] of FEDERAL_KEYS) {
      if (prop[key]) programs[displayName] = prop[key];
    }
    if (Object.keys(programs).length > 0) { fed.programs = programs; hasContent = true; }

    if (hasContent) { fields[dotPath] = fed; count++; }
  });

  const relSource = relative(ROOT, baseSpecPath).replace(/\\/g, '/');
  writeAnnotationFile(outPath, schemaRef, fields, 'Federal annotation layer', relSource);
  console.log(`  federal: ${count} annotated fields → ${outPath}`);
}

// ---------------------------------------------------------------------------
// State annotations (from resolved spec, run per state)
// ---------------------------------------------------------------------------

/**
 * @param {string} resolvedSpecPath - Path to the state-resolved OpenAPI YAML
 * @param {string} outPath - Output file path (e.g. generated/annotations/california.yaml)
 * @param {string} stateName - State name (e.g. 'california', 'colorado')
 * @param {string} [schemaRef='applications/Application']
 */
export function generateStateAnnotations(resolvedSpecPath, outPath, stateName, schemaRef = 'applications/Application') {
  const spec = yaml.load(readFileSync(resolvedSpecPath, 'utf-8'));
  const schemas = spec.components?.schemas || {};

  const stateKeys = new Map();
  const stateProgramMap = STATE_PROGRAM_MAPS[stateName] || {};
  for (const [col, key] of Object.entries(stateProgramMap)) {
    stateKeys.set(key, col);
  }

  const stateMeta = STATE_META_PATTERNS[stateName] || {};
  const fields = {};
  let count = 0;

  walkProperties(schemas, (prop, dotPath) => {
    if (!prop || typeof prop !== 'object') return;

    const st = {};
    let hasContent = false;

    // Carry label forward so the state file is self-contained
    if (prop.description) st.label = prop.description;

    if (stateMeta.statute && prop[stateMeta.statute]) {
      st.statute = prop[stateMeta.statute];
      hasContent = true;
    }
    if (stateMeta.notes && prop[stateMeta.notes]) {
      st.notes = prop[stateMeta.notes];
      hasContent = true;
    }

    const programs = {};
    for (const [key, displayName] of stateKeys) {
      if (prop[key]) programs[displayName] = prop[key];
    }
    if (Object.keys(programs).length > 0) { st.programs = programs; hasContent = true; }

    if (hasContent) { fields[dotPath] = st; count++; }
  });

  const displayName = stateName.charAt(0).toUpperCase() + stateName.slice(1);
  const relSource = relative(ROOT, resolvedSpecPath).replace(/\\/g, '/');
  writeAnnotationFile(outPath, schemaRef, fields, `${displayName} annotation layer`, relSource);
  console.log(`  ${stateName}: ${count} annotated fields → ${outPath}`);
}
