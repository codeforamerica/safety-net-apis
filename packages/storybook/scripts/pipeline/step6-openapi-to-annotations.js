/**
 * Step 6: Resolved OpenAPI spec → annotations YAML
 *
 * Walks the resolved spec and extracts x- extensions into the annotation format
 * consumed by the form engine (dot-path keyed fields with programs, statutes, etc.).
 *
 * Output: overwrites src/contracts/application/annotations.yaml
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { dirname } from 'path';
import yaml from 'js-yaml';
import {
  INCLUDED_ENTITIES,
  ANNOTATION_PATH_PREFIX,
  HOUSEHOLD_PREFIX_GROUPS,
  FEDERAL_PROGRAM_MAP,
  CA_PROGRAM_MAP,
} from './entity-map.js';

// Build reverse maps: x-extension key → display name
const ALL_PROGRAM_KEYS = new Map();
for (const [col, key] of Object.entries(FEDERAL_PROGRAM_MAP)) {
  ALL_PROGRAM_KEYS.set(key, col);
}
for (const [col, key] of Object.entries(CA_PROGRAM_MAP)) {
  ALL_PROGRAM_KEYS.set(key, col);
}

/**
 * @param {string} specPath - Path to resolved OpenAPI YAML
 * @param {string} outPath - Path for output annotations YAML
 */
export function generateAnnotations(specPath, outPath) {
  const text = readFileSync(specPath, 'utf-8');
  const spec = yaml.load(text);
  const schemas = spec.components?.schemas || {};

  const fields = {};
  let fieldCount = 0;

  for (const entity of INCLUDED_ENTITIES) {
    const schema = schemas[entity];
    if (!schema?.properties) continue;

    const prefix = ANNOTATION_PATH_PREFIX[entity];

    for (const [propName, prop] of Object.entries(schema.properties)) {
      // Skip relationship refs and arrays-of-refs
      if (prop.$ref) continue;
      if (prop.type === 'array' && prop.items?.$ref) continue;

      // Handle nested objects (Household sub-groups)
      if (prop.type === 'object' && prop.properties) {
        for (const [subName, subProp] of Object.entries(prop.properties)) {
          const dotPath = prefix ? `${prefix}.${propName}.${subName}` : `${propName}.${subName}`;
          const entry = extractAnnotation(subProp);
          if (entry) {
            fields[dotPath] = entry;
            fieldCount++;
          }
        }
        continue;
      }

      const dotPath = prefix ? `${prefix}.${propName}` : propName;
      const entry = extractAnnotation(prop);
      if (entry) {
        fields[dotPath] = entry;
        fieldCount++;
      }
    }
  }

  const doc = {
    '# Annotation metadata for the Application data model.': null,
    '# Generated by the CSV-to-overlay pipeline. Do not edit by hand.': null,
  };

  // Write as clean YAML with a header comment
  const header = [
    '# Annotation metadata for the Application data model.',
    '# Generated by the CSV-to-overlay pipeline. Do not edit by hand.',
    '# Maps form-engine dot-paths to program requirements, statutes, and data sources.',
    '',
  ].join('\n');

  const body = yaml.dump({ fields }, {
    lineWidth: 120,
    noRefs: true,
    quotingType: '"',
    forceQuotes: false,
  });

  mkdirSync(dirname(outPath), { recursive: true });
  writeFileSync(outPath, header + body);

  console.log(`  ${fieldCount} annotated fields`);
}

/** Extract annotation entry from a property's x- extensions */
function extractAnnotation(prop) {
  if (!prop || typeof prop !== 'object') return null;

  const entry = {};
  let hasContent = false;

  // Label from description
  if (prop.description) {
    entry.label = prop.description;
  }

  // Source
  if (prop['x-source']) {
    entry.source = prop['x-source'];
    hasContent = true;
  }

  // Federal statute
  if (prop['x-statute']) {
    entry.statute = prop['x-statute'];
    hasContent = true;
  }

  // CA statute
  if (prop['x-ca-statute']) {
    entry['ca-statute'] = prop['x-ca-statute'];
    hasContent = true;
  }

  // OBBBA
  if (prop['x-obbba']) {
    entry.obbba = prop['x-obbba'];
    hasContent = true;
  }

  // Programs (both federal and CA)
  const programs = {};
  for (const [key, displayName] of ALL_PROGRAM_KEYS) {
    if (prop[key]) {
      programs[displayName] = prop[key];
    }
  }

  if (Object.keys(programs).length > 0) {
    entry.programs = programs;
    hasContent = true;
  }

  return hasContent ? entry : null;
}
